## Function: <code>solve\_multiple\_j\_for\_factors\_mod\_N(j_list, m, l, g, N, ..)</code>
Attempts to factor N completely, given a list of n frequencies [j_1, ..., j_n] yielded by n independent runs of the quantum part of Seifert's variation [[Seifert01]](https://doi.org/10.1007/3-540-45353-9_24) of Shor's order-finding algorithm [[Shor94]](https://doi.org/10.1109/SFCS.1994.365700) when computing the order r of g modulo N, for g an element selected uniformly at random from the multiplicative group of the ring of integers modulo N.

This by using the algorithm from [[E21b]](https://doi.org/10.1007/s11128-021-03069-1) to factor N given r, or a positive multiple of r, and the post-processing algorithm from [[E24t]](https://diva-portal.org/smash/get/diva2:1902626/FULLTEXT01.pdf) (see Sect. 5.4) and [[E21]](https://doi.org/10.1515/jmc-2020-0006), with supporting functions from [[E24]](https://doi.org/10.1145/3655026), to find r, or a positive multiple of r, given the n frequencies [j_1, ..., j_n].

Throughout this function, the algorithms are as described in [[E24t]](https://diva-portal.org/smash/get/diva2:1902626/FULLTEXT01.pdf), [[E21]](https://doi.org/10.1515/jmc-2020-0006) and [[E21b]](https://doi.org/10.1007/s11128-021-03069-1). The notation is also inherited from said works.

> This convenience function simply calls solve_multiple_j_for_r(), and then solve_r_for_factors(), passing along r. To access all options of these functions, call them manually in sequence instead.

## Import directive
```python
from quaspy.factoring.general.postprocessing.ekera import solve_multiple_j_for_factors_mod_N
```

## Parent module
- [<code>ekera</code>](README.md)

## Prototype
```python
def solve_multiple_j_for_factors_mod_N(j_list : list,
                                       m : int,
                                       l : int,
                                       g : int | gmpy2.mpz,
                                       N : int | gmpy2.mpz,
                                       tau : int = 0,
                                       c_solve : int = 1,
                                       c_factor : int = 1,
                                       k : int | None = None,
                                       delta : float = 0.99,
                                       precision : int | None = None,
                                       enumerate : bool | quaspy.orderfinding.general.postprocessing.ekera.EnumerationOptions = False,
                                       timeout : int | None | quaspy.utils.timeout.Timeout = None,
                                       verbose : bool = False,
                                       opt_speculative : bool = True)
```

## Parameters
| <b>Name</b> | <b>Description</b> |
| ----------- | ------------------ |
| j_list | The n frequencies [j_1, ..., j_n] where j_1, ..., j_n are integers on [0, 2^(m + l)). |
| m | A positive integer m such that r < 2^m. |
| l | A positive integer l ≈ m / s for s a tradeoff factor. The length of the control register is m + l in the quantum part of the order-finding algorithm. |
| g | The group element g of order r. |
| N | The integer N. |
| tau | An integer tau on [0, l]. Used to scale the basis for the lattice L^tau that is used in the post-processing, and that is generated by the vector (j_1, ..., j_n, 2^tau), and by the n vectors (2^(m + l), 0, ..., 0) thru (0, ..., 0, 2^(m + l), 0). |
| c_solve | A parameter c_solve >= 1 that specifies the maximum size of the missing smooth component d in r = d * r_tilde when solving j for r, or a multiple of r. As is explained in [[E24]](https://doi.org/10.1145/3655026), increasing c increases the success probability, at the expense of increasing the runtime. |
| c_factor | A parameter c_factor >= 1 that specifies the maximum size of the missing smooth component in lambda'(N) when solving r for the complete factorization of N. As is explained in [[E21b]](https://doi.org/10.1007/s11128-021-03069-1), increasing c increases the success probability, at the expense of increasing the runtime. |
| k | The maximum number of iterations to perform when factoring N given the order r, or a multiple of r. Defaults to None.<br><br>If k is set to None, as many iterations as are necessary to completely factor N will be performed. If k is explicitly specified, and the complete factorization of N has not been found after k iterations, an exception of type IncompleteFactorizationException will be raised. |
| delta | The parameter delta to use when delta-LLL-reducing the basis for the lattice L^tau used in the post-processing. Must be on the interval (1/4, 1]. A polynomial runtime in the dimension of the lattice is only guaranteed for delta < 1. |
| precision | The precision to use when computing the Gram–Schmidt projection factors as a part of delta-LLL-reducing the basis for the lattice L^tau used in the post-processing.<br><br>The precision may be set to None, as is the default, in which case the projection factors are represented as exact quotients. |
| enumerate | A flag that may be set to True to enumerate vectors in the lattice L^tau (until r or a positive multiple of r is found or the specified timeout has elapsed), or to EnumerationOptions.SVP to consider only a shortest non-zero vector in L^tau as returned by performing a limited enumeration, or to False to consider only a shortest non-zero vector as returned by LLL.<br><br>May also be set to EnumerationOptions.BOUNDED_BY_TAU or to EnumerationOptions.BOUNDED_BY_TAU_COMPLETE in which case all vectors within distance R of the origin of the lattice L^tau are enumerated, where R depends on tau as R = sqrt(n + 1) * 2^(m + tau). In the former case, the enumeration is aborted early as soon as r or a positive multiple of r is found. In the latter case, the enumeration runs to completion, after which the minimum candidate for r is taken as r. |
| timeout | A timeout after which an IncompleteFactorizationException or TimeoutError will be raised and the computation aborted. More specifically, if the process of factoring N given r, or a multiple of r, has been initiated, an IncompleteFactorizationException will be raised, otherwise a TimeoutError will be raised, when the timeout elapses.<br><br>The timeout may be represented as an integer specifying the timeout in seconds, or as an instance of the Timeout class. May be set to None, as is the default, in which case no timeout is enforced. |
| verbose | A flag that may be set to True to print intermediary results and status updates when executing the post-processing algorithm. |
| opt_speculative | A flag that may be set to True to indicate that Alg. 2 in [[E24]](https://doi.org/10.1145/3655026) should be used instead of Alg. 3 to find the missing cm-smooth component of r. In most cases, Alg. 2 is faster than Alg. 3, but in the worst case Alg. 2 is a lot slower than Alg. 3. For further details, see [[E24]](https://doi.org/10.1145/3655026). |

## Return value
The set of all distinct prime factors that divide N, or None, if a positive multiple of r could not be found given the n frequencies [j_1, ..., j_n].

