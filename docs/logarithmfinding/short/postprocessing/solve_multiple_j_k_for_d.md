## Function: <code>solve\_multiple\_j\_k\_for\_d(j_k_list, m, l, g, x, ..)</code>
Attempts to compute the short discrete logarithm d = log_g x given a list of n frequency pairs [[j_1, k_1], ..., [j_n, k_n]] yielded by n independent runs of the quantum part of Ekerå–Håstad's algorithm [[EH17]](https://doi.org/10.1007/978-3-319-59879-6_20) by using the classical post-processing algorithm from [[E20]](https://doi.org/10.1007/s10623-020-00783-2) and [[E24t]](https://diva-portal.org/smash/get/diva2:1902626/FULLTEXT01.pdf) (see Sect. 5.6).

## Import directive
```python
from quaspy.logarithmfinding.short.postprocessing import solve_multiple_j_k_for_d
```

## Parent module
- [<code>postprocessing</code>](README.md)

## Prototype
```python
def solve_multiple_j_k_for_d(j_k_list : list,
                             m : int,
                             l : int,
                             g : CyclicGroupElement,
                             x : CyclicGroupElement,
                             tau : int = 0,
                             delta : float = 0.99,
                             precision : int | None = None,
                             enumerate : bool | quaspy.logarithmfinding.short.postprocessing.EnumerationOptions = False,
                             timeout : int | None | quaspy.utils.timeout.Timeout = None,
                             verbose : bool = False)
```

## Parameters
| <b>Name</b> | <b>Description</b> |
| ----------- | ------------------ |
| j_k_list | The n frequency pairs [[j_1, k_1], ..., [j_n, k_n]] where j_1, ..., j_n are integers on [0, 2^(m + l)) and k_1, ..., k_n are integers on [0, 2^l). |
| m | A positive integer m such that d < 2^m. |
| l | A positive integer l ≈ m / s for s a tradeoff factor. The two control registers in the quantum part of the algorithm are of lengths m + l and l qubits, respectively. |
| g | The group element g. |
| x | The group element x = g^d. |
| tau | An integer tau on [0, l]. Used to scale the basis for the lattice L^tau that is used in the post-processing, and that is generated by the vector (j_1, ..., j_n, 2^tau), and by the n vectors (2^(m + l), 0, ..., 0) thru (0, ..., 0, 2^(m + l), 0). |
| delta | The parameter delta to use when delta-LLL-reducing the basis for the lattice L^tau used in the post-processing. Must be on the interval (1/4, 1]. A polynomial runtime in the dimension of the lattice is only guaranteed for delta < 1. |
| precision | The precision to use when computing the Gram–Schmidt projection factors as a part of delta-LLL-reducing the basis for the lattice L^tau used in the post-processing.<br><br>The precision may be set to None, as is the default, in which case the projection factors are represented as exact quotients. |
| enumerate | A flag that may be set to True to enumerate vectors in the lattice L^tau (until d is found or the specified timeout has elapsed), or to EnumerationOptions.CVP to consider only a closest vector in the lattice as returned by performing a limited enumeration, or to False to consider only the vector returned by Babai's nearest plane algorithm.<br><br>May also be set to EnumerationOptions.BOUNDED_BY_TAU in which case all vectors within distance R of the origin of the lattice L^tau are enumerated, where R depends on tau as R = sqrt(n + 1) * 2^(m + tau). |
| timeout | A timeout after which a TimeoutError will be raised and the computation aborted.<br><br>The timeout may be represented as an integer specifying the timeout in seconds, or as an instance of the Timeout class. May be set to None, as is the default, in which case no timeout is enforced. |
| verbose | A flag that may be set to True to print intermediary results and status updates when executing the post-processing algorithm. |

## Return value
The logarithm d, or None, if solving for d fails.

