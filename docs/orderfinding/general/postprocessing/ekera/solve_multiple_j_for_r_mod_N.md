## Function: <code>solve\_multiple\_j\_for\_r\_mod\_N(j_list, m, l, g, N, ..)</code>
Attempts to compute the order r of g mod N, or a positive integer multiple thereof, given a list of n frequencies [j_1, ..., j_n] yielded by n independent runs of the quantum part of Seifert's variation [[Seifert01]](https://doi.org/10.1007/3-540-45353-9_24) of Shor's order-finding algorithm [[Shor94]](https://doi.org/10.1109/SFCS.1994.365700) as described in [[E24t]](https://diva-portal.org/smash/get/diva2:1902626/FULLTEXT01.pdf) (see Sect. 5.4) and [[E21]](https://doi.org/10.1515/jmc-2020-0006) (see App. A). This by using Ekerå's lattice-based classical post-processing from [[E24t]](https://diva-portal.org/smash/get/diva2:1902626/FULLTEXT01.pdf) and [[E21]](https://doi.org/10.1515/jmc-2020-0006), with supporting functions from [[E24]](https://doi.org/10.1145/3655026).

> This convenience function simply calls solve_multiple_j_for_r() with g setup by calling IntegerModRingMulSubgroupElement(g, N).

## Import directive
```python
from quaspy.orderfinding.general.postprocessing.ekera import solve_multiple_j_for_r_mod_N
```

## Parent module
- [<code>ekera</code>](README.md)

## Prototype
```python
def solve_multiple_j_for_r_mod_N(j_list : list,
                                 m : int,
                                 l : int,
                                 g : int | gmpy2.mpz,
                                 N : int | gmpy2.mpz,
                                 tau : int = 0,
                                 c : int = 1,
                                 delta : float = 0.99,
                                 precision : int | None = None,
                                 enumerate : bool | quaspy.orderfinding.general.postprocessing.ekera.EnumerationOptions = False,
                                 timeout : int | None | quaspy.utils.timeout.Timeout = None,
                                 verbose : bool = False,
                                 opt_speculative : bool = True)
```

## Parameters
| <b>Name</b> | <b>Description</b> |
| ----------- | ------------------ |
| j_list | The n frequencies [j_1, ..., j_n] where j_1, ..., j_n are integers on [0, 2^(m + l)). |
| m | A positive integer m such that r < 2^m. |
| l | A positive integer l ≈ m / s for s a tradeoff factor. |
| g | The group element g of order r modulo N. |
| N | The modulus N. |
| tau | An integer tau on [0, l]. Used to scale the basis for the lattice L^tau that is used in the post-processing, and that is generated by the vector (j_1, ..., j_n, 2^tau), and by the n vectors (2^(m + l), 0, ..., 0) thru (0, ..., 0, 2^(m + l), 0). |
| c | A parameter c >= 1 that specifies the maximum size of the missing cm-smooth component d in r = d * r_tilde when solving j for r, for cm-smooth as defined in [[E24]](https://doi.org/10.1145/3655026).<br><br>As is explained in [[E24]](https://doi.org/10.1145/3655026), increasing c increases the success probability, at the expense of increasing the runtime. |
| delta | The parameter delta to use when delta-LLL-reducing the basis for the lattice L^tau used in the post-processing. Must be on the interval (1/4, 1]. A polynomial runtime in the dimension of the lattice is only guaranteed for delta < 1. |
| precision | The precision to use when computing the Gram–Schmidt projection factors as a part of delta-LLL-reducing the basis for the lattice L^tau used in the post-processing.<br><br>The precision may be set to None, as is the default, in which case the projection factors are represented as exact quotients. |
| enumerate | A flag that may be set to True to enumerate vectors in the lattice L^tau (until r or a positive multiple of r is found or the specified timeout has elapsed), or to EnumerationOptions.SVP to consider only a shortest non-zero vector in L^tau as returned by performing a limited enumeration, or to False to consider only a shortest non-zero vector as returned by LLL.<br><br>May also be set to EnumerationOptions.BOUNDED_BY_TAU or to EnumerationOptions.BOUNDED_BY_TAU_COMPLETE in which case all vectors within distance R of the origin of the lattice L^tau are enumerated, where R depends on tau as R = sqrt(n + 1) * 2^(m + tau). In the former case, the enumeration is aborted early as soon as r or a positive multiple of r is found. In the latter case, the enumeration runs to completion, after which the minimum candidate for r is taken as r. |
| timeout | A timeout after which a TimeoutError will be raised and the computation aborted.<br><br>The timeout may be represented as an integer specifying the timeout in seconds, or as an instance of the Timeout class. May be set to None, as is the default, in which case no timeout is enforced. |
| verbose | A flag that may be set to True to print intermediary results and status updates when executing the post-processing algorithm. |
| opt_speculative | A flag that may be set to True to indicate that Alg. 2 in [[E24]](https://doi.org/10.1145/3655026) should be used instead of Alg. 3 to find the missing cm-smooth component of r. In most cases, Alg. 2 is faster than Alg. 3, but in the worst case Alg. 2 is a lot slower than Alg. 3. For further details, see [[E24]](https://doi.org/10.1145/3655026). |

## Return value
The order r of g mod N, or some positive multiple thereof, or None, if solving for r fails.

