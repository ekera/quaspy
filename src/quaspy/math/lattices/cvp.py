""" @brief  A module for solving the closest vector problem (CVP). """

from .babai import babai;
from .enumerate import enumerate;
from .gram_schmidt import gram_schmidt;

from ..vectors import norm2;
from ..matrices import dimensions;

from ...utils.timeout import Timeout;

from gmpy2 import mpz;
from gmpy2 import mpq;
from gmpy2 import mpfr;

from ...math.lattices.lll import LLL_DEFAULT_DELTA;

def solve_cvp(
  B : list[list[int | mpz]],
  t : list[int | mpz | mpq | mpfr],
  timeout : int | None | Timeout = None,
  gs : list[list[list[int | mpz | mpq | mpfr]]] | None = None,
  precision : int | None = None) -> list[int | mpz]:

  """ @brief  Let L be the lattice generated by the rows of the integer basis
              matrix B, and let t be a target vector in the span of L. Then this
              function computes and returns a closest vector to t in L.

      The basis matrix B is represented as a list of lists [b_1, ..., b_n],
      where b_i = [b_i1, ..., b_id] for i = 1, ..., n are the n rows of B.

      The vector t is analogously represented as a list [t_1, ..., t_d].

      It is assumed that the basis B is delta-LLL-reduced.

      It is required that B has integer entries of type int or mpz.

      Furthermore, it is required that B has full rank and is square since the
      enumerate() function that this function calls currently imposes these
      requirements. Said requirements may be relaxed in the future.

      @param B  The matrix B.

      @param t  The vector t.

      @param timeout  A timeout after which a TimeoutError will be raised and
                      the computation aborted.

                      The timeout may be represented as an integer specifying
                      the timeout in seconds, or as an instance of the Timeout
                      class. May be set to None, as is the default, in which
                      case no timeout is enforced.

      @param gs   The list [Bs, M], where Bs is the Gram–Schmidt orthogonalized
                  basis for B, and M is the associated matrix of Gram–Schmidt
                  projection factors, as returned by calling

                     [Bs, M] = gram_schmidt(B, precision = precision),

                  or None, in which case this function will make the above call.

                  If you plan to call this functions repeatedly for the same
                  lattice, then time may be saved by not re-computing Bs and M
                  for each call.

                  Note that the basis B is typically LLL-reduced by calling
                  lll() before calling this function. The lll() function can
                  return not only B but also Bs and M (since Bs and M are
                  incrementally computed as a part of the LLL reduction process)
                  allowing you to directly pass them along to this function.

      @param precision  The precision to use when computing the Gram–Schmidt
                        projection factors. May be set to None, in which case
                        the projection factors are represented as exact
                        quotients.

                        Note that this parameter only has an effect if gs is
                        set to None as the Gram–Schmidt orthogonalized basis Bs
                        and the associated matrix M of Gram–Schmidt projection
                        factors are otherwise pre-computed.

      @return   A closest vector to t in L, the lattice generated by the rows of
                the integer basis matrix B.  """

  # Initial setup.
  timeout = Timeout.parse(timeout);
  timeout.check();

  (_, d) = dimensions(B);

  if None == gs:
    [Bs, M] = gram_schmidt(B, precision);
  else:
    [Bs, M] = gs;

  # Check the timeout.
  timeout.check();

  # Find a vector v that is close to t in the lattice generated by B.
  v = babai(B, t, Bs = Bs);

  # Check the timeout.
  timeout.check();

  # Compute R^2 = | v - t |^2.
  R2 = norm2([v[i] - t[i] for i in range(d)]);

  # Enumerate all vectors within distance R of v and see if there is a closer
  # vector v' to t than v. If so, set v to v', update R, and re-start the
  # enumeration (since R is now smaller this is likely more efficient).

  # Set the proceed flag.
  proceed = True;

  while proceed:

    # Unset the proceed flag.
    proceed = False;

    # Check the timeout.
    timeout.check();

    # Start the enumeration.
    for vp in enumerate(B,
                        R2,
                        t,
                        timeout = timeout,
                        gs = [Bs, M]):

      tmp = norm2([vp[i] - t[i] for i in range(d)]);

      if tmp < R2:
        v = vp;
        R2 = tmp;

        # Set the proceed flag.
        proceed = True;

        break; # Stop the enumeration.

  return v;